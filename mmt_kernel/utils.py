def to_display_data(message,omdoc=None):
    """wraps the message into the display_data format"""
    if(omdoc):
        return {
            'data': {
                'text/html': message,
                'application/omdoc' : omdoc
            },
            'metadata': {},
            'transient': {},
        }
    else:
        return {
            'data': {
                'text/html': message,
            },
            'metadata': {},
            'transient': {}
        }
    
charMap = {
	"MD" : "âš",
	"DD" : "â™",
	"OD" : "â˜",
	"sharp" : "â™¯",
	"flat" : "â™­",
	"U" : "ğ’°",
	"ra" : "â†’",
	"la" : "â†",
	"lra" : "â†”",
	"rA" : "â‡’",
	"lA" : "â‡",
	"lrA" : "â‡”",
	"raa" : "âŸ¶",
	"laa" : "âŸµ",
	"lraa" : "âŸ·",
	"rAA" : "âŸ¹",
	"lAA" : "âŸ¸",
	"lrAA" : "âŸº",
	"hra" : "â†ª",
	"hla" : "â†©",
	"rightarrow" : "â†’",
	"leftarrow" : "â†",
	"leftrightarrow" : "â†”",
	"Rightarrow" : "â‡’",
	"Leftarrow" : "â‡",
	"Leftrightarrow" : "â‡”",
	"hookrightarrow" : "â†ª",
	"hookleftarrow" : "â†©",
	"longrightarrow" : "âŸ¶",
	"longleftarrow" : "âŸµ",
	"longleftrightarrow" : "âŸ·",
	"Longrightarrow" : "âŸ¹",
	"Longleftarrow" : "âŸ¸",
	"Longleftrightarrow" : "âŸº",
	"bla" : "â†¦",
	"blA" : "â¤‡",
	"blaa" : "âŸ¼",
	"blAA" : "â¤‡",
	"bra" : "â†¤",
	"brA" : "â¤†",
	"braa" : "âŸ»",
	"brAA" : "â¤†",
	"ls" : "â‡",
	"lss" : "âŸ¿",
	"rs" : "â‡œ",
	"rss" : "â¬³",
	"mapsto" : "â†¦",
	"Mapsto" : "â¤‡",
	"longmapsto" : "âŸ¼",
	"Longmapsto" : "â¤‡",
	"mapsfrom" : "â†¤",
	"Mapsfrom" : "â¤†",
	"longmapsfrom" : "âŸ»",
	"Longmapsfrom" : "â¤†",
	"rightsquigarrow" : "â‡",
	"longrightsquigarrow" : "âŸ¿",
	"leftsquigarrow" : "â‡œ",
	"longleftsquigarrow" : "â¬³",
	"lolli" : "âŠ¸",
	"rewrites" : "âŸ¿",
	"uparrow" : "â†‘",
	"downarrow" : "â†“",
	"updownarrow" : "â†•",
	"Uparrow" : "â‡‘",
	"Downarrow" : "â‡“",
	"Updownarrow" : "â‡•",
	"contra" : "â†¯",
	"check" : "âœ“",
	"ast" : "âˆ—",
	"star" : "â˜…",
	"cdot" : "â‹…",
	"circ" : "âˆ˜",
	"bullet" : "âˆ™",
	"times" : "Ã—",
	"pm" : "Â±",
	"mp" : "âˆ“",
	"wedge" : "âˆ§",
	"vee" : "âˆ¨",
	"cap" : "âˆ©",
	"cup" : "âˆª",
	"sqcap" : "âŠ“",
	"sqcup" : "âŠ”",
	"oplus" : "âŠ•",
	"ominus" : "âŠ–",
	"otimes" : "âŠ—",
	"oslash" : "âŠ˜",
	"oast" : "âŠ›",
	"ocirc" : "âŠš",
	"odot" : "âŠ™",
	"o0" : "â“ª",
	"o1" : "â‘ ",
	"o2" : "â‘¡",
	"o3" : "â‘¢",
	"o4" : "â‘£",
	"o5" : "â‘¤",
	"o6" : "â‘¥",
	"o7" : "â‘¦",
	"o8" : "â‘§",
	"o9" : "â‘¨",
	"bigtimes" : "â¨‰",
	"bigcirc" : "â—¯",
	"bigwedge" : "â‹€",
	"bigvee" : "â‹",
	"bigcap" : "â‹‚",
	"bigcup" : "â‹ƒ",
	"bigdiamond" : "â—‡",
	"bigoplus" : "â¨",
	"bigotimes" : "â¨‚",
	"subset" : "âŠ‚",
	"supset" : "âŠƒ",
	"sq" : "âŠ†â€",
	"subseteq" : "âŠ†â€",
	"supseteq" : "âŠ‡",
	"nsubset" : "âŠ„",
	"nsupset" : "âŠ…",
	"nsubseteq" : "âŠˆ",
	"nsupseteq" : "âŠ‰",
	"subsetneq" : "âŠŠ",
	"supsetneq" : "âŠ‹",
	"leq" : "â‰¤",
	"geq" : "â‰¥",
	"ll" : "â‰ª",
	"gg" : "â‰«",
	"nleq" : "â‰¨",
	"ngeq" : "â‰©",
	"sqsubset" : "âŠ",
	"sqsupset" : "âŠ",
	"sqsubseteq" : "âŠ‘",
	"sqsupseteq" : "âŠ’",
	"in" : "âˆˆ",
	"nin" : "âˆ‰",
	"ni" : "âˆ‹",
	"nni" : "âˆŒ",
	"neq" : "â‰ ",
	"doteq" : "â‰",
	"eq" : "âšŒ",
	"equiv" : "â‰¡",
	"nequiv" : "â‰¢",
	"sim" : "âˆ¼",
	"simeq" : "â‰ƒ",
	"nsimeq" : "â‰„",
	"cong" : "â‰…",
	"ncong" : "â‰‡",
	"approx" : "â‰ˆ",
	"napprox" : "â‰‰",
	"approxeq" : "â‰Š",
	"triangleright" : "â–·",
	"triangleleft" : "â—",
	"blacktriangleright" : "â–¶",
	"blacktriangleleft" : "â—€",
	"der" : "âŠ¦",
	"rightassert" : "âŠ¦",
	"vdash" : "âŠ¢",
	"dashv" : "âŠ£",
	"models" : "âŠ§",
	"top" : "âŠ¤",
	"bot" : "âŠ¥",
	"neg" : "Â¬",
	"forall" : "âˆ€",
	"exists" : "âˆƒ",
	"nexists" : "âˆ„",
	"box" : "â–¡",
	"square" : "â–¡",
	"diamond" : "â‹„",
	"es" : "âˆ…",
	"emptyset" : "âˆ…",
	"aleph" : "×",
	"infty" : "âˆ",
	"sum" : "âˆ‘",
	"prod" : "âˆ",
	"coprod" : "âˆ",
	"amalg" : "âˆ",
	"comp" : "âˆ",
	"complement" : "âˆ",
	"sm" : "âˆ–",
	"setminus" : "âˆ–",
	"colon" : "âˆ¶",
	"coloneq" : "â‰”",
	"langle" : "âŸ¨",
	"rangle" : "âŸ©",
	"llangle" : "âŸª",
	"rrangle" : "âŸ«",
	"llbracket" : "âŸ¦",
	"rrbracket" : "âŸ§",
	"lceil" : "âŒˆ",
	"rceil" : "âŒ‰",
	"lfloor" : "âŒŠ",
	"rfloor" : "âŒ‹",
	"ulcorner" : "âŒœ",
	"urcorner" : "âŒ",
	"llcorner" : "âŒ",
	"lrcorner" : "âŒŸ",
	"ldots" : "â€¦",
	"vdots" : "â‹®",
	"N" : "â„•",
	"Z" : "â„¤",
	"Q" : "â„š",
	"R" : "â„",
	"C" : "â„‚",
	"B" : "â„¬",
	"pow" : "â„˜",
	"Alpha" : "Î‘",
	"Beta" : "Î’",
	"Gamma" : "Î“",
	"Delta" : "Î”",
	"Epsilon" : "Î•",
	"Zeta" : "Î–",
	"Eta" : "Î—",
	"Theta" : "Î˜",
	"Iota" : "Î™",
	"Kappa" : "Îš",
	"Lambda" : "Î›",
	"Mu" : "Îœ",
	"Nu" : "Î",
	"Xi" : "Î",
	"Omikron" : "ÎŸ",
	"Pi" : "Î ",
	"Rho" : "Î¡",
	"Sigma" : "Î£",
	"Tau" : "Î¤",
	"Upsilon" : "Î¥",
	"Phi" : "Î¦",
	"Chi" : "Î§",
	"Psi" : "Î¨",
	"Omega" : "Î©",
	"alpha" : "Î±",
	"beta" : "Î²",
	"gamma" : "Î³",
	"delta" : "Î´",
	"epsilon" : "Îµ",
	"zeta" : "Î¶",
	"eta" : "Î·",
	"theta" : "Ï‘",
	"iota" : "Î¹",
	"kappa" : "Îº",
	"lambda" : "Î»",
	"mu" : "Î¼",
	"nu" : "Î½",
	"xi" : "Î¾",
	"omikron" : "Î¿",
	"pi" : "Ï€",
	"rho" : "Ï",
	"sigma" : "Ïƒ",
	"tau" : "Ï„",
	"upsilon" : "Ï…",
	"phi" : "Ï†",
	"chi" : "Ï‡",
	"psi" : "Ïˆ",
	"omega" : "Ï‰",
	"super0" : "â°",
	"super1" : "Â¹  ",
	"super2" : "Â²",
	"super3" : "Â³",
	"super4" : "â´",
	"super5" : "âµ",
	"super6" : "â¶",
	"super7" : "â·",
	"super8" : "â¸",
	"super9" : "â¹",
	"superplus" : "âº",
	"superminus" : "â»",
	"superequal" : "â¼",
	"superopen" : "â½",
	"superclose" : "â¾",
	"sub0" : "â‚€",
	"sub1" : "â‚",
	"sub2" : "â‚‚",
	"sub3" : "â‚ƒ",
	"sub4" : "â‚„",
	"sub5" : "â‚…",
	"sub6" : "â‚†",
	"sub7" : "â‚‡",
	"sub8" : "â‚ˆ",
	"sub9" : "â‚‰",
	"subplus" : "â‚Š",
	"subminus" : "â‚‹",
	"subequal" : "â‚Œ",
	"subopen" : "â‚",
	"subclose" : "â‚",
	"prec" : "â‰º",
	"preceq" : "â‰¼",
	"succ" : "â‰»",
	"succeq" : "â‰½",
	"nabla" : "âˆ‡",
	"partial" : "âˆ‚",
	"dagger" : "â€ ",
	"int" : "âˆ«",
	"oint" : "âˆ®",
	"ln" : "ã‘",
	"perp" : "âŠ¥",
	"parallel" : "âˆ¥",
}

# this can be used with extended JSONObject class
# def toPythonDict2(self,JSONObject):
#     """Translates a info.kwarc.mmt.api.utils.JSONObject to a 
#     Python-only dict that can be passed to the widget constructors"""
#     pythonDict = {}
#     for key in JSONObject:
#         keystring = key.value()
#         JV = JSONObject[key].get() # A info.kwarc.mmt.api.utils.JSONValue object
#         if str(JV.getClass()) != "class info.kwarc.mmt.api.utils.JSONArray":
#             # we can handle every JSONValue, except JSONArrays with this
#             pythonDict.update({keystring : JV.value()})
#         else:
#             # here the special case for JSONArrays
#             JSONArray = JV
#             pythonList = []
#             for JSONValue in JSONArray: # JSONValus is also a info.kwarc.mmt.api.utils.JSONValue object
#                 if str(JSONValue.getClass()) == "class info.kwarc.mmt.api.utils.JSONScalaObject":
#                     # at the moment we only use this for widgets. If we are planning on
#                     # sending other ScalaObjects here, we have to discriminate further
#                     WidgetPython = JSONValue.value()
#                     pythonList.append(widgets[WidgetPython.getID()]) 
#                 else:
#                     pythonList.append(JSONValue.value())
#             pythonDict.update({keystring : pythonList})
    
#     return pythonDict

